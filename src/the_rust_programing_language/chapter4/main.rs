fn main() {
    // 所有権
    // メモリはコンパイラがコンパイル時にチェクする一定の規則と共に所有権システムを通じて管理されている
    // どの所有権機能も、実行中にプログラムの動作を遅くすることはない

    // スタックとヒープ
    // 値がスタックに積まれるかヒープに置かれるかは、言語の振る舞い方や特定の決断を下す理由などに影響を与える

    // スタック
    //  得た順番に値を並べ、求悪の順番で値を取り除いていく
    //   Last in, first out ( FIFO ) 最後に入れたものが最初に出てくる
    //   お皿を重ねていくイメージ
    //   スタックにデータを追加することを「スタックにpushする」という
    //   スタックからデータを削除することを「スタックからpopする」という
    //   Navigator.push, Navigator.pop と同じ
    // スタックは高速
    //  新しいデータを置いたり、データを取得する場所を探す必要がない
    //  常に一番上のデータを取れば良い
    // スタック上のデータは全て既知の固定サイズでなければならない
    //  コンパイル時にサイズが分からなかったり、サイズが可変のデータについてはヒープに保存

    // 所有権規則
    // Rustの各値は、所有者と呼ばれる変数と対応している
    // いかなる時も所有者は一つである
    // 所有者がスコープから外れたら、値は破棄される

    // 変数スコープ
    // スコープとは、要素が有効になるプログラム内の範囲のこと
    {                       // sはここでは有効ではない
        let s = "hello";    // sはここから有効になる
                            // sを用いた作業が可能
    }                       // sはもう有効ではない

    // String型の所有権
    // 文字列リテラルでは、文字列の値はプログラムにハードコードされる
    // 例えばユーザー入力を受け付け、それを保持したいときにはどうするか？
    // String型はヒープにメモリを確保するため、コンパイル時にはサイズが不明なテキストも保持することができる
    // from関数を使用して、文字列リテラルからString型を生成できる
    // この種の文字列は可変化することができる
    let mut s = String::from("Hello");
    s.push_str(", world!");
    println!("{}", s);

    let mut s = String::from("Hello");
    s.push_str(", world!");
    println!("{}", s);

    // なぜString型は可変化できるのに、リテラルはできないのか？
    // この違いは、これら二つの型がメモリを扱う方法にある

    // メモリと確保
    // 文字列リテラルの場合
    // 文字列リテラルの場合は、中身はコンパイル時に判明しているので、テキストは最終的な
    // バイナリファイルに直接ハードコードされる。このため、文字列リテラルは高速で効率的
    // これらの特性は、その文字列リテラルの「不変性」があるため。
    // コンパイル時にサイズが不明であったり、プログラム実行に合わせてサイズが可変な
    // テキスト用に一塊のメモリをバイナリに確保しておくことは不可能である

    // String型の場合
    // 可変かつ伸長可能なテキストをサポートするために、コンパイル時には不明な量のメモリ
    // をヒープに確保して内容を保持する
    //  メモリは、実行時にOSに要求される → String::from を読んだら、メモリを要求する
    //  String型を使用し終わったら、OSにこのメモリを返却する方法が必要
    // ガベージコレクタ（GC）月言語では、GCがこれ以上使用されないメモリを検知して片付ける
    // GCがない言語はメモリが使用されないことを見計らって、明示的に返却する必要がある
    // Rustでは、GCがあるため、メモリを所有している変数がスコープを抜けたら、
    // メモリは自動的に返却される。

    // 変数とデータの相互作用法：ムーブ
    // case 1
    let x = 5;
    let y = x;

    // case 2
    let s1 = String::from("hello");
    let s2 = s1;

    // case1, case2 との違い
    // String型はメモリへのポインタ（ptr）、長さ（len）、許容量（capacity）の三つからなる
    // 長さ：String型の中身が現在使用しているメモリ量をバイトで表したもの
    // 許容量：String型がOSから受け取った前メモリ量をバイトで表したもの
    // s1 を s2 に代入すると String型のデータがコピーされる。つまり、スタックの上にある
    // ポインタ、長さ、許容量をコピーする。
    // ここで重要なのは、Rustがヒープデータもコピーするわけではないということ
    // case2 の形でコピーした場合、s2 と s1 がスコープから抜けたら...
    // 両方とも同じメモリを解放しようとする。これを「二重解放」エラーという
    // メモリを二回解放することはメモリの崩壊、意図せぬメモリの書き換えに繋がる
    // したがって、case2 はエラーになる

    // shallow copy と deep copy
    // shallow copy と呼ばれる代わりに「ムーブ」として知られている
    // 「s1 は s2 にムーブされた」と表現する

    // 整数は例外
    // 整数のようなコンパイル時に既知のサイズを持つ型は、スタック上にすっぽり保持されるので、
    // 実際の値をコピーするのも高速だからです。これは、変数yを生成した後にもxを無効化した
    // くなる理由がないことを意味します。 換言すると、ここでは、shallow copyと
    // deep copyの違いがないことになり、 cloneメソッドを呼び出しても、
    // 一般的なshallow copy以上のことをしなくなり、 そのまま放置しておける

    let s = String::from("hello"); // sがスコープに入る

    takes_ownership(s); // sの値が関数にムーブされ...
                        // ... ここではもう有効ではない
    let x = 5; // xがスコープに入る
    makes_copy(x); // xも関数にムーブされるが、i32はCopyなので、この後にxを使ってもOK

    // 参照
    // 関数の引数に参照を取ることを借用と呼びます
    // 変数が標準で不変なのと全く同様に、参照も不変なのです。参照している何かを変更することは叶わないわけです
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    // '{}'の長さは、{}です
    println!("The length of '{}' is {}.", s1, len);

    // &mut sで可変な参照を生成し、 some_string: &mut Stringで可変な参照を受け入れなければなりません
    fn main() {
        let mut s = String::from("hello");

        change(&mut s);
    }

    fn change(some_string: &mut String) {
        some_string.push_str(", world");
    }

    // 特定のスコープで、ある特定のデータに対しては、 一つしか可変な参照を持てない
    // 以下が失敗する
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);

    // スコープを抜けてからであれば新しい参照を作ることができる
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる

    let r2 = &mut s;

    // 可変な借用
    let mut s = String::from("hello");

    let r1 = &s; // 問題なし
    let r2 = &s; // 問題なし
    let r3 = &mut s; // 大問題！
}

fn takes_ownership(some_string: String) {
    // some_stringがスコープに入る。
    println!("{}", some_string);
} // ここでsome_stringがスコープを抜け、`drop`が呼ばれる。後ろ盾してたメモリが解放される。
  //

fn makes_copy(some_integer: i32) {
    // some_integerがスコープに入る
    println!("{}", some_integer);
} // ここでsome_integerがスコープを抜ける。何も特別なことはない。

// アンド記号が参照であり、これのおかげで所有権をもらうことなく値を参照することができるのです。
// この&s1という記法により、s1の値を参照する参照を生成することができますが、
// これを所有することはありません。
// 所有してないということは、指している値は、参照がスコープを抜けてもドロップされない
fn calculate_length(s: &String) -> usize {
    s.len()
}